\hypertarget{network_8h}{}\section{src/network.h File Reference}
\label{network_8h}\index{src/network.\+h@{src/network.\+h}}
{\ttfamily \#include $<$assert.\+h$>$}\\*
{\ttfamily \#include \char`\"{}layer.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}data\+\_\+structure.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}activation\+\_\+functions.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}util.\+h\char`\"{}}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structNetwork}{Network}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{data__structure_8h_a051bd2b17d42e70d86b4314e0dd8881e}{vol\+\_\+t} $\ast$$\ast$ \hyperlink{network_8h_ad48307c6437d8da3206a07e54257c89f}{batch\+\_\+t}
\item 
typedef struct \hyperlink{structNetwork}{Network} \hyperlink{network_8h_a50de83d30d1821b64a30c139c234e065}{Network}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structNetwork}{Network} $\ast$ \hyperlink{network_8h_ac098d6b97e198ef0923b41129ea2a98f}{make\+\_\+network} (int n)
\begin{DoxyCompactList}\small\item\em This allocates memory for pointers to n layers. \end{DoxyCompactList}\item 
void \hyperlink{network_8h_a394bf2bf3bc173512ddf3a2160b9aef4}{network\+\_\+add} (\hyperlink{structNetwork}{Network} $\ast$net, \hyperlink{structLayer}{Layer} $\ast$layer)
\begin{DoxyCompactList}\small\item\em add the specified layer to the network, this informs the type of layer to the network \end{DoxyCompactList}\item 
void \hyperlink{network_8h_a51ca2f00f92543a2e52644da5593accf}{net\+\_\+summary} (\hyperlink{structNetwork}{Network} $\ast$net)
\begin{DoxyCompactList}\small\item\em gives a brief summary of the type of layers in the net and the number of key operations taken within each layer \end{DoxyCompactList}\item 
void \hyperlink{network_8h_a8156c41e6fa67372d63b81f603fb7415}{initialize\+\_\+network} (\hyperlink{structNetwork}{Network} $\ast$net, int batch\+\_\+size)
\begin{DoxyCompactList}\small\item\em allocate buffer space to the layers in the network \end{DoxyCompactList}\item 
void \hyperlink{network_8h_a3fbfc99bdf0d9b7f756aa9ed4f1902a9}{free\+\_\+network} (\hyperlink{structNetwork}{Network} $\ast$net)
\begin{DoxyCompactList}\small\item\em free the allocated buffer space \end{DoxyCompactList}\item 
void \hyperlink{network_8h_ae2a806a89ddc15991856941ab6220b4a}{net\+\_\+forward} (\hyperlink{structNetwork}{Network} $\ast$net)
\begin{DoxyCompactList}\small\item\em forward from the data layer \end{DoxyCompactList}\item 
int \hyperlink{network_8h_a34f5b4812af800b2aa66f49b77d34031}{net\+\_\+num\+\_\+category} (\hyperlink{structNetwork}{Network} $\ast$net)
\begin{DoxyCompactList}\small\item\em return the number of categories the network is categorizing \end{DoxyCompactList}\item 
\hyperlink{layer_8h_a2b2a1226894e9f27b848908f83310852}{label\+\_\+t} \hyperlink{network_8h_a15497ca5a2b37846434a620cf9688bcf}{net\+\_\+predict} (\hyperlink{structNetwork}{Network} $\ast$net)
\begin{DoxyCompactList}\small\item\em forward and make prediction based on the last layer \end{DoxyCompactList}\item 
void \hyperlink{network_8h_a4e9f0e5d7d7f5fb94247abcc373fa1af}{net\+\_\+test} (\hyperlink{structNetwork}{Network} $\ast$net, \hyperlink{data__structure_8h_a051bd2b17d42e70d86b4314e0dd8881e}{vol\+\_\+t} $\ast$$\ast$input, \hyperlink{layer_8h_a2b2a1226894e9f27b848908f83310852}{label\+\_\+t} $\ast$labels, int n)
\begin{DoxyCompactList}\small\item\em forward the given inputs and output the accuracy analysis \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Typedef Documentation}
\index{network.\+h@{network.\+h}!batch\+\_\+t@{batch\+\_\+t}}
\index{batch\+\_\+t@{batch\+\_\+t}!network.\+h@{network.\+h}}
\subsubsection[{batch\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vol\+\_\+t}$\ast$$\ast$ {\bf batch\+\_\+t}}\hypertarget{network_8h_ad48307c6437d8da3206a07e54257c89f}{}\label{network_8h_ad48307c6437d8da3206a07e54257c89f}
\index{network.\+h@{network.\+h}!Network@{Network}}
\index{Network@{Network}!network.\+h@{network.\+h}}
\subsubsection[{Network}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf Network}  {\bf Network}}\hypertarget{network_8h_a50de83d30d1821b64a30c139c234e065}{}\label{network_8h_a50de83d30d1821b64a30c139c234e065}


\subsection{Function Documentation}
\index{network.\+h@{network.\+h}!free\+\_\+network@{free\+\_\+network}}
\index{free\+\_\+network@{free\+\_\+network}!network.\+h@{network.\+h}}
\subsubsection[{free\+\_\+network(\+Network $\ast$net)}]{\setlength{\rightskip}{0pt plus 5cm}void free\+\_\+network (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a3fbfc99bdf0d9b7f756aa9ed4f1902a9}{}\label{network_8h_a3fbfc99bdf0d9b7f756aa9ed4f1902a9}


free the allocated buffer space 

\index{network.\+h@{network.\+h}!initialize\+\_\+network@{initialize\+\_\+network}}
\index{initialize\+\_\+network@{initialize\+\_\+network}!network.\+h@{network.\+h}}
\subsubsection[{initialize\+\_\+network(\+Network $\ast$net, int batch\+\_\+size)}]{\setlength{\rightskip}{0pt plus 5cm}void initialize\+\_\+network (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net, }
\item[{int}]{batch\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a8156c41e6fa67372d63b81f603fb7415}{}\label{network_8h_a8156c41e6fa67372d63b81f603fb7415}


allocate buffer space to the layers in the network 


\begin{DoxyParams}{Parameters}
{\em net} & the network \\
\hline
{\em batch\+\_\+size} & how many intermediate images to hold within each buffer, default to 1\\
\hline
\end{DoxyParams}
after all the layers has been added, call initialize\+\_\+network this routine checks the number of layers added matches with declaration

the following fives an example of how to initialize an network 
\begin{DoxyCode}
1 Network* net = make\_network(8);
2 network\_add(net, make\_conv\_layer(28, 28, 1, 5, 6, 1, 0));
3 network\_add(net, make\_max\_pool\_layer(net->layers[0]->out\_sx, net->layers[0]->out\_sy,
       net->layers[0]->out\_depth, 2, 2));
4 network\_add(net, make\_conv\_layer(net->layers[1]->out\_sx, net->layers[1]->out\_sy, net->layers[1]->out\_depth,
       5, 16, 1, 0));
5 network\_add(net, make\_max\_pool\_layer(net->layers[2]->out\_sx, net->layers[2]->out\_sy,
       net->layers[2]->out\_depth, 2, 2));
6 network\_add(net, make\_fc\_layer(net->layers[3]->out\_sx, net->layers[3]->out\_sy, net->layers[3]->out\_depth,
       120));
7 network\_add(net, make\_relu\_layer(net->layers[4]->out\_sx, net->layers[4]->out\_sy,
       net->layers[4]->out\_depth));
8 network\_add(net, make\_fc\_layer(net->layers[5]->out\_sx, net->layers[5]->out\_sy, net->layers[5]->out\_depth,
       10));
9 network\_add(net, make\_softmax\_layer(net->layers[6]->out\_sx, net->layers[6]->out\_sy,
       net->layers[6]->out\_depth));
10 conv\_load(net->layers[0], mnist\_conv1\_params, mnist\_conv1\_data);
11 conv\_load(net->layers[2], mnist\_conv2\_params, mnist\_conv2\_data);
12 fc\_load(net->layers[4], mnist\_ip1\_params, mnist\_ip1\_data);
13 fc\_load(net->layers[6], mnist\_ip2\_params, mnist\_ip2\_data);
14 initialize\_network(net, 1);
\end{DoxyCode}
 \index{network.\+h@{network.\+h}!make\+\_\+network@{make\+\_\+network}}
\index{make\+\_\+network@{make\+\_\+network}!network.\+h@{network.\+h}}
\subsubsection[{make\+\_\+network(int n)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Network} $\ast$ make\+\_\+network (
\begin{DoxyParamCaption}
\item[{int}]{n}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_ac098d6b97e198ef0923b41129ea2a98f}{}\label{network_8h_ac098d6b97e198ef0923b41129ea2a98f}


This allocates memory for pointers to n layers. 


\begin{DoxyParams}{Parameters}
{\em n} & number of layers. \\
\hline
\end{DoxyParams}
\index{network.\+h@{network.\+h}!net\+\_\+forward@{net\+\_\+forward}}
\index{net\+\_\+forward@{net\+\_\+forward}!network.\+h@{network.\+h}}
\subsubsection[{net\+\_\+forward(\+Network $\ast$net)}]{\setlength{\rightskip}{0pt plus 5cm}void net\+\_\+forward (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_ae2a806a89ddc15991856941ab6220b4a}{}\label{network_8h_ae2a806a89ddc15991856941ab6220b4a}


forward from the data layer 

\index{network.\+h@{network.\+h}!net\+\_\+num\+\_\+category@{net\+\_\+num\+\_\+category}}
\index{net\+\_\+num\+\_\+category@{net\+\_\+num\+\_\+category}!network.\+h@{network.\+h}}
\subsubsection[{net\+\_\+num\+\_\+category(\+Network $\ast$net)}]{\setlength{\rightskip}{0pt plus 5cm}int net\+\_\+num\+\_\+category (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{network_8h_a34f5b4812af800b2aa66f49b77d34031}{}\label{network_8h_a34f5b4812af800b2aa66f49b77d34031}


return the number of categories the network is categorizing 

\index{network.\+h@{network.\+h}!net\+\_\+predict@{net\+\_\+predict}}
\index{net\+\_\+predict@{net\+\_\+predict}!network.\+h@{network.\+h}}
\subsubsection[{net\+\_\+predict(\+Network $\ast$net)}]{\setlength{\rightskip}{0pt plus 5cm}void net\+\_\+predict (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a15497ca5a2b37846434a620cf9688bcf}{}\label{network_8h_a15497ca5a2b37846434a620cf9688bcf}


forward and make prediction based on the last layer 

this assumes the last layer is a softmax layer \index{network.\+h@{network.\+h}!net\+\_\+summary@{net\+\_\+summary}}
\index{net\+\_\+summary@{net\+\_\+summary}!network.\+h@{network.\+h}}
\subsubsection[{net\+\_\+summary(\+Network $\ast$net)}]{\setlength{\rightskip}{0pt plus 5cm}void net\+\_\+summary (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a51ca2f00f92543a2e52644da5593accf}{}\label{network_8h_a51ca2f00f92543a2e52644da5593accf}


gives a brief summary of the type of layers in the net and the number of key operations taken within each layer 

\index{network.\+h@{network.\+h}!net\+\_\+test@{net\+\_\+test}}
\index{net\+\_\+test@{net\+\_\+test}!network.\+h@{network.\+h}}
\subsubsection[{net\+\_\+test(\+Network $\ast$net, vol\+\_\+t $\ast$$\ast$input, label\+\_\+t $\ast$labels, int n)}]{\setlength{\rightskip}{0pt plus 5cm}void net\+\_\+test (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net, }
\item[{{\bf vol\+\_\+t} $\ast$$\ast$}]{input, }
\item[{{\bf label\+\_\+t} $\ast$}]{labels, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a4e9f0e5d7d7f5fb94247abcc373fa1af}{}\label{network_8h_a4e9f0e5d7d7f5fb94247abcc373fa1af}


forward the given inputs and output the accuracy analysis 


\begin{DoxyParams}{Parameters}
{\em net} & the network \\
\hline
{\em input} & the input images \\
\hline
{\em label} & the actual input classification \\
\hline
{\em n} & the size of input \\
\hline
\end{DoxyParams}
\index{network.\+h@{network.\+h}!network\+\_\+add@{network\+\_\+add}}
\index{network\+\_\+add@{network\+\_\+add}!network.\+h@{network.\+h}}
\subsubsection[{network\+\_\+add(\+Network $\ast$net, Layer $\ast$layer)}]{\setlength{\rightskip}{0pt plus 5cm}void network\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf Network} $\ast$}]{net, }
\item[{{\bf Layer} $\ast$}]{layer}
\end{DoxyParamCaption}
)}\hypertarget{network_8h_a394bf2bf3bc173512ddf3a2160b9aef4}{}\label{network_8h_a394bf2bf3bc173512ddf3a2160b9aef4}


add the specified layer to the network, this informs the type of layer to the network 


\begin{DoxyParams}{Parameters}
{\em net} & the network \\
\hline
{\em layer} & the layer\\
\hline
\end{DoxyParams}
For example, one can do\+: 
\begin{DoxyCode}
1 Network* net = make\_network(11);
2 Layer* l = make\_conv\_layer(32, 32, 3, 5, 16, 1, 2);
3 network\_add(net, l);
\end{DoxyCode}
 